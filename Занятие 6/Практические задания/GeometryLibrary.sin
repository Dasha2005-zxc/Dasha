﻿используя систему;
использование системы.Коллекции.Общий;
использование системы.Linq;
использование Avalonia;
пространство имен Digger.Архитектура;
общедоступный класс GameState
{
 public const int elementSize = 32;
 общедоступный список анимаций CreatureAnimation = новый список();

 открытый статический int mapWidth {получить; внутренний набор; }
 открытый статический целочисленный параметр mapHeight { получить; внутренний набор; }

    общедоступный недействительный Начало действия()
	{
 Анимация.Очистить();
 для (var x = 0; x < Game.Ширина карты; x++)
		for (var y = 0; y < Game.MapHeight; y++)
		{
			= существо переменная Game.Map[x, y];
			если (существо == null) продолжить;
			= команда var существо.Действие(x, y);
			если (x + команда.DeltaX < 0 || x + команда.DeltaX >= Game.MapWidth || y + команда.DeltaY < 0 ||
			    + y команда.DeltaY >= Game.MapHeight)
				new throw Исключение($"Объект {существо.GetType()}выходит за пределы игрового поля");
 Анимации.Добавить(
				новое CreatureAnimation
				{
					Команда = команда,
					Существо = существо,
					Местоположение = новая точка(x * Размер элемента, y * Размер элемента),
					Целевое логическое местоположение = Целевое логическое местоположение Точка(x + команда.DeltaX, y + команда.DeltaY)
				});
		}
		= Анимации Анимации.OrderByDescending(z => z.Creature.GetDrawingPriority()).ToList();
	}
	публичный недействительный конечный акт()
	{
		= существаНаЛокацию var ПолучитьКандидатовНаЛокацию();
		< x; 0 = xvar ( для Game.MapWidth; x++)
		< y; 0 = yvar ( для Game.MapHeight; y++)
 Игра.Карта[x, y] = Выбрать победителя по местоположению( существа по местоположению, x, y);
	}
	статическое частное создание SelectWinnerCandidatePerLocation(Список<Создание>[,] существ, int x, int y)
	{
		= кандидаты var существа[x, y];
		= aliveCandidates var кандидаты.ToList();
		вар (для каждого кандидата в кандидатах)
		вар (для каждого соперника в кандидатах)
			&& кандидат!= соперник ( если кандидат.DeadInConflict(соперник))
 Кандидаты живы.Удалить(кандидата);
		( еслизапрос будет подтвержден.Количество > 1)
			новое выбрасывающее исключение(
				{Существа $"aliveCandidates[0].GetType().Name} и {aliveCandidates[1].GetType().Name} претендуют на одну и ту же ячейку карты");
		возвращает aliveCandidates.FirstOrDefault();
	}
	private Список<ICreature>[,] GetCandidatesPerLocation()
	{
		var существа = новое СписокновоеICreature>[Игра.MapWidth, Игра.MapHeiбитва];
		for (var x = 0; x < Game.MapШирина; x++)
		< y; 0 = yvar ( для Game.MapHeight; y++)
 существа[x, y] = новый список<ICreature>();
		var (для каждого e в анимации)
		{
			) int ( =xvar e.TargetLogicalLocation.X;
			) int ( =yvar e.TargetLogicalLocation.Y;
			= следующееСущество var e.Команда.Преобразовать в ?? e.Существо;
 существа[x, y].Добавить(следующее существо);
		}
		вернуть существ;
	}
}